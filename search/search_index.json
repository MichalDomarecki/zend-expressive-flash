{
    "docs": [
        {
            "location": "/",
            "text": "zend-expressive-flash\n\n\n\n\n\n\nProvides flash messages for PSR-7 middleware using\n\nzend-expressive-session\n.\n\n\nInstallation\n\n\nRun the following to install this library:\n\n\n$ composer require zendframework/zend-expressive-flash\n\n\n\nDocumentation\n\n\nDocumentation is \nin the doc tree\n, and can be compiled using \nmkdocs\n:\n\n\n$ mkdocs build\n\n\n\nYou may also \nbrowse the documentation online\n.",
            "title": "zend-expressive-flash"
        },
        {
            "location": "/#zend-expressive-flash",
            "text": "Provides flash messages for PSR-7 middleware using zend-expressive-session .",
            "title": "zend-expressive-flash"
        },
        {
            "location": "/#installation",
            "text": "Run the following to install this library:  $ composer require zendframework/zend-expressive-flash",
            "title": "Installation"
        },
        {
            "location": "/#documentation",
            "text": "Documentation is  in the doc tree , and can be compiled using  mkdocs :  $ mkdocs build  You may also  browse the documentation online .",
            "title": "Documentation"
        },
        {
            "location": "/intro/",
            "text": "zend-expressive-flash\n\n\nFlash messages\n are self-expiring, session-based messages. They are typically\nused when when you need to redirect after processing a request (e.g., when using\nthe \nPost-Redirect-Get pattern\n),\nbut want to display a message back to the user indicating a processing result.\n\n\nAs an example, I may want to display a \"Thank You\" message to the user after\nsuccessfully completing a form. I can do that with flash messages.\n\n\nWhen processing, I would create the message in my middleware:\n\n\n$flashMessages->flash('form-complete', 'Thank you; your submission was recorded.');\n\n\n\nOn the subsequent request, my middleware would pull that message:\n\n\n$message = $flashMessages->getFlash('form-complete');\n\n\n\nOn any subsequent requests, the message is no longer available!\n\n\nInstallation\n\n\nTo use the component, install via \nComposer\n:\n\n\n$ composer require zendframework/zend-expressive-flash\n\n\n\n\n\nPersistence required\n\n\nzend-expressive-flash depends on zend-expressive-session, which defines\nabstractions around session containers \u2014 for use within applications for\naccessing session data \u2014 and session persistence (how the session data\nis persisted between requests, and reported to the client).\n\n\nPersistence requires a \npersistence adapter\n. We offer one basd on PHP's\nsession extension via the package zend-expressive-session-ext; others may also\nbe available soon.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#zend-expressive-flash",
            "text": "Flash messages  are self-expiring, session-based messages. They are typically\nused when when you need to redirect after processing a request (e.g., when using\nthe  Post-Redirect-Get pattern ),\nbut want to display a message back to the user indicating a processing result.  As an example, I may want to display a \"Thank You\" message to the user after\nsuccessfully completing a form. I can do that with flash messages.  When processing, I would create the message in my middleware:  $flashMessages->flash('form-complete', 'Thank you; your submission was recorded.');  On the subsequent request, my middleware would pull that message:  $message = $flashMessages->getFlash('form-complete');  On any subsequent requests, the message is no longer available!",
            "title": "zend-expressive-flash"
        },
        {
            "location": "/intro/#installation",
            "text": "To use the component, install via  Composer :  $ composer require zendframework/zend-expressive-flash",
            "title": "Installation"
        },
        {
            "location": "/intro/#persistence-required",
            "text": "zend-expressive-flash depends on zend-expressive-session, which defines\nabstractions around session containers \u2014 for use within applications for\naccessing session data \u2014 and session persistence (how the session data\nis persisted between requests, and reported to the client).  Persistence requires a  persistence adapter . We offer one basd on PHP's\nsession extension via the package zend-expressive-session-ext; others may also\nbe available soon.",
            "title": "Persistence required"
        },
        {
            "location": "/messages/",
            "text": "Flash Messages\n\n\nFlash messages are contained within a \nZend\\Expressive\\Flash\\FlashMessagesInterface\n\nimplementation. That interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Flash;\n\nuse Zend\\Expressive\\Session\\SessionInterface;\n\ninterface FlashMessagesInterface\n{\n    /**\n     * Flash values scheduled for next request.\n     */\n    public const FLASH_NEXT = self::class . '::FLASH_NEXT';\n\n    /**\n     * Create an instance from a session container.\n     *\n     * Flash messages will be retrieved from and persisted to the session via\n     * the `$sessionKey`.\n     */\n    public static function createFromSession(\n        SessionInterface $session,\n        string $sessionKey = self::FLASH_NEXT\n    ) : FlashMessagesInterface;\n\n    /**\n     * Set a flash value with the given key.\n     *\n     * Flash values are accessible on the next \"hop\", where a hop is the\n     * next time the session is accessed; you may pass an additional $hops\n     * integer to allow access for more than one hop.\n     *\n     * @param mixed $value\n     */\n    public function flash(string $key, $value, int $hops = 1) : void;\n\n    /**\n     * Set a flash value with the given key, but allow access during this request.\n     *\n     * Flash values are generally accessible only on subsequent requests;\n     * using this method, you may make the value available during the current\n     * request as well.\n     *\n     * @param mixed $value\n     */\n    public function flashNow(string $key, $value, int $hops = 1) : void;\n\n    /**\n     * Retrieve a flash value.\n     *\n     * Will return a value only if a flash value was set in a previous request,\n     * or if `flashNow()` was called in this request with the same `$key`.\n     *\n     * WILL NOT return a value if set in the current request via `flash()`.\n     *\n     * @param mixed $default Default value to return if no flash value exists.\n     * @return mixed\n     */\n    public function getFlash(string $key, $default = null);\n\n    /**\n     * Retrieve all flash values.\n     *\n     * Will return all values was set in a previous request, or if `flashNow()`\n     * was called in this request.\n     *\n     * WILL NOT return values set in the current request via `flash()`.\n     *\n     * @return array\n     */\n    public function getFlashes() : array;\n\n    /**\n     * Clear all flash values.\n     *\n     * Affects the next and subsequent requests.\n     */\n    public function clearFlash() : void;\n\n    /**\n     * Prolongs any current flash messages for one more hop.\n     */\n    public function prolongFlash() : void;\n}\n\n\n\nA default implementation is provided in the class\n\nZend\\Expressive\\Flash\\FlashMessages\n, but you may implement the interface\nyourself if you have special needs that fall outside this standard\nimplementation.\n\n\nThe instance will generally be injected into your request under the attribute\n\nZend\\Expressive\\Flash\\FlashMessageMiddleware::FLASH_ATTRIBUTE\n, which evaluates\nto \nflash\n.\n\n\nUsage\n\n\nFirst, pull the flash messages from the request:\n\n\n$flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE);\n\n// or\n$flashMessages = $request->getAttribute('flash');\n\n\n\nTo create a flash message for the next request:\n\n\n$flashMessages->flash($messageName, $messageValue);\n\n\n\nTo retrieve a message you previously flashed:\n\n\n$message = $flashMessages->getFlash($messageName);\n\n\n\nTo retrieve all messages you previously flashed:\n\n\n$messages = $flashMessages->getFlashes();\n\n\n\nHops\n\n\nSometimes you may want a flash message to persist for longer than a single\nrequest. As an example, with a multi-page form, you may want to store messages\nuntil all pages have been filled.\n\n\nzend-expressive-flash allows you to specify \nhops\n, indicating how many requests\nthe flash message will persist for. The default value is \n1\n, indicating a\nsingle hop. This value is provided when you call \nflash()\n as an optional third\nargument.\n\n\nTo have a message persist for three \"hops\", you might call \nflash()\n as follows:\n\n\n$flashMessages->flash($messageName, $messageValue, 3);\n\n\n\nSometimes you may want to ensure all messages persist for one more hop. To do\nthat:\n\n\n$flashMessages->prolongFlash();\n\n\n\nIf you want to clear all flash methods, no matter the number of hops:\n\n\n$flashMessages->clearFlash();\n\n\n\nNote, however, that this clears them for the \nnext request\n, not the current\none.\n\n\nAccessing messages in the current request\n\n\nWhen you create a flash message, it is available \nin the next request\n, but not\nthe \ncurrent request\n. If you want access to it in the current request as well,\nuse the \nflashNow()\n method instead of \nflash()\n:\n\n\n$flashMessages->flashNow($messageName, $messageValue);\n\n\n\nThe signature of this method is the same as for \nflash()\n, and allows you to\noptionally provide a \n$hops\n value as well.",
            "title": "Flash Messages"
        },
        {
            "location": "/messages/#flash-messages",
            "text": "Flash messages are contained within a  Zend\\Expressive\\Flash\\FlashMessagesInterface \nimplementation. That interface is defined as follows:  namespace Zend\\Expressive\\Flash;\n\nuse Zend\\Expressive\\Session\\SessionInterface;\n\ninterface FlashMessagesInterface\n{\n    /**\n     * Flash values scheduled for next request.\n     */\n    public const FLASH_NEXT = self::class . '::FLASH_NEXT';\n\n    /**\n     * Create an instance from a session container.\n     *\n     * Flash messages will be retrieved from and persisted to the session via\n     * the `$sessionKey`.\n     */\n    public static function createFromSession(\n        SessionInterface $session,\n        string $sessionKey = self::FLASH_NEXT\n    ) : FlashMessagesInterface;\n\n    /**\n     * Set a flash value with the given key.\n     *\n     * Flash values are accessible on the next \"hop\", where a hop is the\n     * next time the session is accessed; you may pass an additional $hops\n     * integer to allow access for more than one hop.\n     *\n     * @param mixed $value\n     */\n    public function flash(string $key, $value, int $hops = 1) : void;\n\n    /**\n     * Set a flash value with the given key, but allow access during this request.\n     *\n     * Flash values are generally accessible only on subsequent requests;\n     * using this method, you may make the value available during the current\n     * request as well.\n     *\n     * @param mixed $value\n     */\n    public function flashNow(string $key, $value, int $hops = 1) : void;\n\n    /**\n     * Retrieve a flash value.\n     *\n     * Will return a value only if a flash value was set in a previous request,\n     * or if `flashNow()` was called in this request with the same `$key`.\n     *\n     * WILL NOT return a value if set in the current request via `flash()`.\n     *\n     * @param mixed $default Default value to return if no flash value exists.\n     * @return mixed\n     */\n    public function getFlash(string $key, $default = null);\n\n    /**\n     * Retrieve all flash values.\n     *\n     * Will return all values was set in a previous request, or if `flashNow()`\n     * was called in this request.\n     *\n     * WILL NOT return values set in the current request via `flash()`.\n     *\n     * @return array\n     */\n    public function getFlashes() : array;\n\n    /**\n     * Clear all flash values.\n     *\n     * Affects the next and subsequent requests.\n     */\n    public function clearFlash() : void;\n\n    /**\n     * Prolongs any current flash messages for one more hop.\n     */\n    public function prolongFlash() : void;\n}  A default implementation is provided in the class Zend\\Expressive\\Flash\\FlashMessages , but you may implement the interface\nyourself if you have special needs that fall outside this standard\nimplementation.  The instance will generally be injected into your request under the attribute Zend\\Expressive\\Flash\\FlashMessageMiddleware::FLASH_ATTRIBUTE , which evaluates\nto  flash .",
            "title": "Flash Messages"
        },
        {
            "location": "/messages/#usage",
            "text": "First, pull the flash messages from the request:  $flashMessages = $request->getAttribute(FlashMessageMiddleware::FLASH_ATTRIBUTE);\n\n// or\n$flashMessages = $request->getAttribute('flash');  To create a flash message for the next request:  $flashMessages->flash($messageName, $messageValue);  To retrieve a message you previously flashed:  $message = $flashMessages->getFlash($messageName);  To retrieve all messages you previously flashed:  $messages = $flashMessages->getFlashes();",
            "title": "Usage"
        },
        {
            "location": "/messages/#hops",
            "text": "Sometimes you may want a flash message to persist for longer than a single\nrequest. As an example, with a multi-page form, you may want to store messages\nuntil all pages have been filled.  zend-expressive-flash allows you to specify  hops , indicating how many requests\nthe flash message will persist for. The default value is  1 , indicating a\nsingle hop. This value is provided when you call  flash()  as an optional third\nargument.  To have a message persist for three \"hops\", you might call  flash()  as follows:  $flashMessages->flash($messageName, $messageValue, 3);  Sometimes you may want to ensure all messages persist for one more hop. To do\nthat:  $flashMessages->prolongFlash();  If you want to clear all flash methods, no matter the number of hops:  $flashMessages->clearFlash();  Note, however, that this clears them for the  next request , not the current\none.",
            "title": "Hops"
        },
        {
            "location": "/messages/#accessing-messages-in-the-current-request",
            "text": "When you create a flash message, it is available  in the next request , but not\nthe  current request . If you want access to it in the current request as well,\nuse the  flashNow()  method instead of  flash() :  $flashMessages->flashNow($messageName, $messageValue);  The signature of this method is the same as for  flash() , and allows you to\noptionally provide a  $hops  value as well.",
            "title": "Accessing messages in the current request"
        },
        {
            "location": "/middleware/",
            "text": "Flash Message Middleware\n\n\nIn order to provide flash messages to your middleware, you will first need to\nregister \nZend\\Expressive\\Flash\\FlashMessageMiddleware\n in your application\npipeline or routed middleware pipeline; additionally, you'll need to ensure\n\nZend\\Expressive\\Session\\SessionMiddleware\n is registered prior to it.\n\n\nThis middleware does the following:\n\n\n\n\nPulls the session container from the request via the attribute\n  \nZend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE\n (\"session\").\n\n\nPasses the container, along with a defined session key, to a factory for\n  generating a \nFlashMessagesInterface\n instance.\n\n\nPasses that instance to a request that the delegate processes, using another\n  request attribute.\n\n\n\n\nDefault configuration\n\n\nBy default, \nFlashMessageMiddleware\n uses \nFlashMessages::createFromSession()\n\nto generate the flash messages container, the key\n\nZend\\Expressive\\Flash\\FlashMessagesInterface::FLASH_NEXT\n (this is a literal\nstring) to pull stored flash messages from the session, and the request\nattribute \nFlashMessageMiddleware::FLASH_ATTRIBUTE\n (\"flash\") to pass the flash\nmessages container to the next middleware.\n\n\nIf you are using the \nzend-component-installer\n\nComposer plugin, the middleware will already be wired for you. Otherwise, you\nwill need to map the middleware to your dependency injection container as an\ninvokable (no constructor arguments).\n\n\nIf these defaults will work for you, you have no further configuration to do.\n\n\nCustom configuration\n\n\nIf you want to specify a different flash messages container implementation, a\ndifferent session key, or a different flash messages request attribute name, you\nwill need to create a new factory for your \nFlashMessagesMiddleware\n. As an\nexample, in the following, I specify:\n\n\n\n\nApplication\\FlashMessages\n as the flash messages container; this class will\n  need to implement \nFlashMessagesInterface\n, including the static method\n  \ncreateFromSession()\n.\n\n\nThe string \nApplication\\FlashMessages::FLASH_NEXT\n as the session key in which\n  flash messages will be stored.\n\n\nThe request attribute \nflash-messages\n in which to store the flash messages\n  container.\n\n\n\n\nuse Application\\FlashMessages;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Flash\\FlashMessageMiddleware;\n\nclass FlashMessageMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FlashMessageMiddleware(\n            FlashMessages::class,\n            FlashMessages::class . '::FLASH_NEXT',\n            'flash-messages'\n        );\n    }\n}\n\n\n\nOnce you have created this factory, map the \nFlashMessageMiddleware\n to it in\nyour dependency injection configuration:\n\n\n'dependencies' => [\n    'factories' => [\n        \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class => FlashMessageMiddlewareFactory::class,\n    ],\n],\n\n\n\nPiping the middleware\n\n\nYou may pipe this middleware either in your application pipeline\n(\nconfig/pipeline.php\n) or a routed middleware pipeline (\nconfig/routes.php\n, or\na delegator factory). When you do, you \nMUST\n register it \nAFTER\n the\n\nZend\\Expressive\\Session\\SessionMiddleware\n as it depends on that middleware for\nits session container.\n\n\nAs an example within an application pipeline:\n\n\n$app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class);\n\n\n\nWithin a routed middleware definition:\n\n\n$app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class,\n    LoginHandler::class,\n]);",
            "title": "Flash Message Middleware"
        },
        {
            "location": "/middleware/#flash-message-middleware",
            "text": "In order to provide flash messages to your middleware, you will first need to\nregister  Zend\\Expressive\\Flash\\FlashMessageMiddleware  in your application\npipeline or routed middleware pipeline; additionally, you'll need to ensure Zend\\Expressive\\Session\\SessionMiddleware  is registered prior to it.  This middleware does the following:   Pulls the session container from the request via the attribute\n   Zend\\Expressive\\Session\\SessionMiddleware::SESSION_ATTRIBUTE  (\"session\").  Passes the container, along with a defined session key, to a factory for\n  generating a  FlashMessagesInterface  instance.  Passes that instance to a request that the delegate processes, using another\n  request attribute.",
            "title": "Flash Message Middleware"
        },
        {
            "location": "/middleware/#default-configuration",
            "text": "By default,  FlashMessageMiddleware  uses  FlashMessages::createFromSession() \nto generate the flash messages container, the key Zend\\Expressive\\Flash\\FlashMessagesInterface::FLASH_NEXT  (this is a literal\nstring) to pull stored flash messages from the session, and the request\nattribute  FlashMessageMiddleware::FLASH_ATTRIBUTE  (\"flash\") to pass the flash\nmessages container to the next middleware.  If you are using the  zend-component-installer \nComposer plugin, the middleware will already be wired for you. Otherwise, you\nwill need to map the middleware to your dependency injection container as an\ninvokable (no constructor arguments).  If these defaults will work for you, you have no further configuration to do.",
            "title": "Default configuration"
        },
        {
            "location": "/middleware/#custom-configuration",
            "text": "If you want to specify a different flash messages container implementation, a\ndifferent session key, or a different flash messages request attribute name, you\nwill need to create a new factory for your  FlashMessagesMiddleware . As an\nexample, in the following, I specify:   Application\\FlashMessages  as the flash messages container; this class will\n  need to implement  FlashMessagesInterface , including the static method\n   createFromSession() .  The string  Application\\FlashMessages::FLASH_NEXT  as the session key in which\n  flash messages will be stored.  The request attribute  flash-messages  in which to store the flash messages\n  container.   use Application\\FlashMessages;\nuse Psr\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Flash\\FlashMessageMiddleware;\n\nclass FlashMessageMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FlashMessageMiddleware(\n            FlashMessages::class,\n            FlashMessages::class . '::FLASH_NEXT',\n            'flash-messages'\n        );\n    }\n}  Once you have created this factory, map the  FlashMessageMiddleware  to it in\nyour dependency injection configuration:  'dependencies' => [\n    'factories' => [\n        \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class => FlashMessageMiddlewareFactory::class,\n    ],\n],",
            "title": "Custom configuration"
        },
        {
            "location": "/middleware/#piping-the-middleware",
            "text": "You may pipe this middleware either in your application pipeline\n( config/pipeline.php ) or a routed middleware pipeline ( config/routes.php , or\na delegator factory). When you do, you  MUST  register it  AFTER  the Zend\\Expressive\\Session\\SessionMiddleware  as it depends on that middleware for\nits session container.  As an example within an application pipeline:  $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class);\n$app->pipe(\\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class);  Within a routed middleware definition:  $app->post('/user/login', [\n    \\Zend\\Expressive\\Session\\SessionMiddleware::class,\n    \\Zend\\Expressive\\Flash\\FlashMessageMiddleware::class,\n    LoginHandler::class,\n]);",
            "title": "Piping the middleware"
        }
    ]
}